/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */


options
{
    //  JJTREE_OUTPUT_DIRECTORY = "./../..";
  //LOOKAHEAD=3;
  //FORCE_LA_CHECK=true; skal måske indkommenteres?
  NODE_DEFAULT_VOID = true;
  STATIC = false;
}

PARSER_BEGIN(TestParser)

package Compiler.Parser.GeneratedFiles;

import Compiler.Parser.whatever;import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

public class TestParser {
    public static void main(String[] args) {
        try {
            parseTextFile("src/Compiler/Parser/test");

        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    public static void parseTextFile(String path){
        try {
            File file = new File(path);

            BufferedReader reader = new BufferedReader(new FileReader(file));
            TestParser parser = new TestParser(reader);
            Node root = parser.start();
            //root.dump("");
            System.out.println(whatever.createDotOutput(root));
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage());
        }
  }
}
  


PARSER_END(TestParser)

SKIP :
{
  " "
| "\r"
| "\t"
| < "//" (~["\n"])* > //This is for skipping a comment
}

TOKEN : /* OPERATORS */
{
  < CREATE : "create" >
| < END : "end" >
| < BLANK : " " | "\t" >
| < NEWLINE : "\n" >
| < COMMA : "," >
| < DOT : "." >
| < MAIN : "main" >
| < ENDOFFILE : "<EOF>" >
| < ASSIGN : "=" >
| < AND : "&" >
| < OR : "|" >
| < NEG : "!" >
| < FUNCTION : "function" >
| < WHILE : "while" >
| < FOR : "for" >
| < FOREACH : "foreach" >
| < IN : "in" >
| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < LCURLY  : "{" >
| < RCURLY : "}" >
| < LHARD : "[" >
| < RHARD : "]" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < CONNECTION : "--" >
| < VERTEX : "Vertex" >
| < EDGE : "Edge" >
| < INT : "int" >
| < REAL : "real" >
| < BOOLEAN : "boolean" >
| < BOOL_VAL : "true" | "false" >
| < DO : "do" >
| < TO : "to" >
| < RETURN : "return" >
| < DCL : "dcl" >
}

TOKEN :
{
  < GRAPH_TYPE : (< GRAPH >) >
| < #GRAPH : "Graph" | "WeightedGraph" | "DiGraph" | "WeightedDiGraph" >
| < CONSTANTS : (< CONSTANT >) >
| < #CONSTANT : "INF" | "NEG_INF" | "Ø" >
| < ADD_SUB : (< addsub >) >
| < #addsub : "+" | "-" >
| < MUL_DIV : (< muldiv >) >
| < #muldiv : "*" | "/" >
| < EQUALITY_OP : (< equality_ope >) >
| < #equality_ope : "==" | "!=" >
| < RELATIONAL_OP : (< relational_ope >) >
| < #relational_ope : "<" | ">" | "<=" | ">=" >
| < COLLECTION_TYPE : (< collection >) >
| < #collection : "Array" | "List" | "Set" | "Queue" | "PriorityQueue" | "Stack" >
| < INUM_VAL : (< DIGIT >) >
| < #DIGIT : "0" | ["1"-"9"](["0"-"9"])* >
| < FNUM_VAL : (< DIGITF >) >
| < #DIGITF : ("0" | ["1"-"9"](["0"-"9"])*)"."(["0"-"9"])+ >
| < IDENTIFIER : (< ID >) >
| < #ID : ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z"] | ["0"-"9"])* >


}

JAVACODE
void skip_to_first_dcl() { 
      Token tok;
      while (true) {
        tok = getToken(1);
        if (tok.kind != NEWLINE ) break;
        tok = getNextToken();
      }
}

JAVACODE
void skip_to_EOF() { 
      Token tok;
      while (true) {
        tok = getToken(1);
        if (tok.kind == EOF ) break;
        tok = getNextToken();
      }
}


SimpleNode start() #START :
{}
{
  prog() {return jjtThis;}
}

void prog() #PROG(>1) :
{}
{
    skip_to_first_dcl() vertex_edge_dcl() (< NEWLINE >)* main() (< NEWLINE >)* funcs_dcl() skip_to_EOF() < EOF >
}

void vertex_edge_dcl() #VERTEX_EDGE_DCL(>1) :
{}
{
    graph_element_types() < DCL > < NEWLINE > attribute_dcl() < END > | empty()
}

void attribute_dcl() #ATTRIBUTE_DCL :
{}
{
    simple_types() identifier() initialization() < NEWLINE > attribute_dcl() | object_types() identifier() < NEWLINE > attribute_dcl() | empty()
}

void main() #void :
{}
{
    <FUNCTION > < MAIN > < LPAREN > < RPAREN > < NEWLINE > block() < END >
}

void block() #BLOCK(>1) :
{}
{
    block_content() < NEWLINE > block() | empty()
}

void block_content() #void :
{}
{
    dcl() | stmt() | empty()
}

void dcl() #DCL :
{}
{
    < CREATE > adt() < END > | simple_types() identifier() initialization()
}

void identifier() #IDENTIFIER :
{Token t;}
{
    t = < IDENTIFIER > {jjtThis.value = t.image;}
}

void initialization() #INITIALIZATION :
{Token t;}
{
    t = < ASSIGN > {jjtThis.value = t.image;} expr() | empty()
}

void adt() #ADT :
{}
{
    graph_type() | collection_type()
}

void graph_type() #GRAPH_TYPE :
{}
{
    < GRAPH_TYPE > identifier() graph_dcl()
}

void graph_dcl() #GRAPH_DCL :
{}
{
    < ASSIGN > member_function_call() | < NEWLINE > graph_elements() | empty()
}

void graph_elements() #GRAPH_ELEMENTS :
{}
{
    graph_vertex_dcl() < NEWLINE > graph_elements() | empty()
}

void graph_vertex_dcl() #GRAPH_VERTEX_DCL :
{}
{
    identifier() < CONNECTION > graph_vertex_dcl1()
}

void graph_vertex_dcl1() #GRAPH_VERTEX_DCL1 :
{}
{
    < LCURLY > vertex_list() < RCURLY > | <IDENTIFIER > weight()
}

void vertex_list() #VERTEX_LIST :
{}
{
    identifier() weight() vertex_list_continuous()
}

void vertex_list_continuous() #VERTEX_LIST_CONTINUOUS :
{}
{
    < COMMA > vertex_list() | empty()
}

void weight() #WEIGHT :
{}
{
    < LHARD > arith_expr() < RHARD > | empty()
}

void expr() #EXPR(>1) :
{}
{
    and_expr() A()
}

void A() #A(>1) :
{}
{
    < OR > and_expr() A() | empty()
}

void and_expr() #AND_EXPR(>1) :
{}
{
    equal_expr() B()
}

void B() #B(>1) :
{}
{
    < AND > equal_expr() B() | empty()
}

void equal_expr() #EQUAL_EXPR(>1) :
{}
{
    rel_expr() equal_expr1()
}

void equal_expr1() #EQUAL_EXPR1(>0) :
{}
{
    < EQUALITY_OP > rel_expr() | empty()
}

void rel_expr() #REL_EXPR(>1) :
{}
{
    arith_expr() rel_expr1()
}

void rel_expr1() #REL_EXPR1(>0) :
{Token t;}
{
  t = < RELATIONAL_OP > {jjtThis.value = t.image;} arith_expr() | empty()
}

void arith_expr() #ARITH_EXPR(>1) :
{}
{
  term() C()
}

void C() #void :
{}
{
  < ADD_SUB > term() C() | empty()
}

void term() #TERM(>1) :
{}
{
    neg_expr() D()
}

void D() #D(>1) :
{Token t;}
{
    t = < MUL_DIV > {jjtThis.value = t.image;} atomic_expr() D() | empty()
}

void neg_expr() #void :
{Token t;}
{
   < NEG > atomic_expr() #NEG_EXPR | atomic_expr()
}

void atomic_expr() #void :
{}
{
    < LPAREN > expr() #PARENTHESIZED_EXPR < RPAREN > | value()
}

void value() #VALUE :
{Token t;}
{
    member_function_call() | t = < INUM_VAL > {jjtThis.value = t.image;} | t = < FNUM_VAL > {jjtThis.value = t.image;} | t = < BOOL_VAL > {jjtThis.value = t.image;} | t = < CONSTANTS > {jjtThis.value = t.image;}
}

void member_function_call() #MEMBER_FUNCTION_CALL :
{}
{
    identifier() member_function_call_tail()
}

void member_function_call_tail() #MEMBER_FUNCTION_CALL_TAIL :
{}
{
    < DOT > member_function_call() | < LPAREN > actual_parameters() < RPAREN > continuous() | empty()
}

void continuous() #CONTINUOUS :
{}
{
    < DOT > member_function_call() | empty()
}


void actual_parameters() #ACTUAL_PARAMETERS :
{}
{
    actual_parameter_list() | empty()
}

void actual_parameter_list() #ACTUAL_PARAMETER_LIST :
{}
{
    expr() actual_parameter_list1()
}

void actual_parameter_list1() #ACTUAL_PARAMETER_LIST1 :
{}
{
    < COMMA > actual_parameter_list() | empty()
}

void simple_types() #SIMPLE_TYPES :
{Token t;}
{
    t = < INT > {jjtThis.value = t.image;} | t = < REAL > {jjtThis.value = t.image;} | t = < BOOLEAN > {jjtThis.value = t.image;}
}


void collection_type() #COLLECTION_TYPE :
{}
{
    < COLLECTION_TYPE > identifier() collection_dcl()
}

void collection_dcl() #COLLECTION_DCL :
{}
{
   < ASSIGN > member_function_call() | < NEWLINE > element_list() | empty()
}

void element_list() #ELEMENT_LIST :
{}
{
    value() < NEWLINE > element_list_continuous()
}

void element_list_continuous() #ELEMENT_LIST1 :
{}
{
    element_list() | empty()
}


void funcs_dcl() #FUNCS_DCL(>1) :
{}
{
    func_dcl() < NEWLINE > funcs_dcl() | empty()
}

void func_dcl() #FUNC_DCL :
{}
{
    ret() < FUNCTION > identifier() < LPAREN > formal_parameters() < RPAREN > block() < END >
}

void ret() #RET :
{}
{
    type() | empty()
}

void formal_parameters() #FORMAL_PARAMETERS :
{}
{
    formal_parameter_list() | empty()
}

void formal_parameter_list() #FORMAL_PARAMETER_LIST :
{}
{
    formal_parameter() formal_parameter_list1()
}

void formal_parameter_list1() #FORMAL_PARAMETER_LIST1 :
{}
{
    < COMMA > formal_parameter_list() | empty()
}

void formal_parameter() #FORMAL_PARAMETER :
{}
{
    type() identifier()
}

void type() #TYPE :
{}
{
    object_types() |  simple_types()
}

void object_types() #OBJECT_TYPES :
{}
{
    < GRAPH_TYPE > | < COLLECTION_TYPE > | graph_element_types()
}

void graph_element_types() #GRAPH_ELEMENT_TYPES :
{Token t;}
{
    t = < VERTEX > {jjtThis.value = t.image;} | t = < EDGE > {jjtThis.value = t.image;}
}

void stmt() #STMT(>1) :
{}
{
    member_function_call() assign_or_func() | loop() | if_statement() | return_stmt()
}

void assign_or_func() #ASSIGN_OR_FUNC :
{}
{
    assignment() | empty()
}

void return_stmt() #RETURN_STMT :
{}
{
    < RETURN > return_expr()
}

void return_expr() #RETURN_EXPR :
{}
{
    expr() | < CREATE > adt() < END >
}


void assignment() #ASSIGNMENT :
{Token t;}
{
    t = < ASSIGN > {jjtThis.value = t.image;} expr()
}

void loop() #LOOP(>1) :
{}
{
  while_statement() | for_statement() | foreach_statement()
}

void while_statement() #WHILE_STATEMENT :
{}
{
    < WHILE > expr() < DO > < NEWLINE > block() < END >
}

void for_statement() #FOR_STATEMENT :
{}
{
    < FOR > identifier() < ASSIGN > integer_value() < TO > integer_value() < DO > < NEWLINE > block() < END >
}

void integer_value() #INTEGER_VALUE :
{}
{
    member_function_call() | < INUM_VAL >
}

void foreach_statement() #FOREACH_STATEMENT :
{}
{
    < FOREACH > identifier() < IN > member_function_call() < DO > < NEWLINE > block() < END >
}

void if_statement() #IF_STATEMENT :
{}
{
    < IF > expr() < THEN > block() else_statement()
}

void else_statement() #ELSE_STATEMENT(>0) :
{}
{
    < ELSE > block() < END > | < END >
}

void empty() : {}
{
     {}
} 






