/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.0 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package Compiler.Parser.GeneratedFiles;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public
class SimpleNode implements Node {
  private String name;
  public String getName() {
    return name;
  }
  public void setName(int suffix) {
    this.name = TestParserTreeConstants.jjtNodeName[id] + suffix;
  }
  public void setName() {
    this.name = TestParserTreeConstants.jjtNodeName[id];
  }

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected TestParser parser;
  protected Token first, last;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(TestParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
    //first = parser.getToken(1);	// new
  }

  public void jjtClose() {
    //last = parser.getToken(0);	// new
  }

  public Token jjtGetFirstToken() { return first; } // new
  public Token getLastToken() { return last; }   // new

  public void jjtSetFirstToken(Token first) {
    this.first = first; // new
  }

  public void jjtSetLastToken(Token last) {
    this.last = last; // new
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }


  public void insertChildren(int index, Node ... newChildren) {
      insertChildren(index, Arrays.asList(newChildren));
  }

  public void insertChildren(int index, List<Node> newChildrenList) {
    if(newChildrenList == null || newChildrenList.size() == 0) {
      throw new IllegalArgumentException("You did not specify any children to be added");
    }
    Node[] newChildren = (Node[]) newChildrenList.toArray();

    if (children == null) {
      children = new Node[newChildren.length + index];
      System.arraycopy(newChildren, 0, children, index, newChildren.length);
    } else {
      int neededArraySize = children.length + newChildren.length;

      Node temp[] = new Node[neededArraySize];
      //We dont want to move the last elements that we are not going to be adding
      int childrenIndex = 0;
      for(int i = 0; i < neededArraySize; i++) {
        if(i == index) {
          for(int j = 0; j < newChildren.length; j++) {
            temp[i] = newChildren[j];
            i++;
          }
          i--; //we need to count back one time because both the inner and outer loop have counted i up
        } else {
          temp[i] = children[childrenIndex];
          childrenIndex++;
        }
      }
      children = temp;
    }
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public Node removeChild(int index) {
    if(index >= jjtGetNumChildren() || index < 0) {
      throw new IndexOutOfBoundsException("The index: " + index +", was out of bounds");
    }

    Node[] temp = new Node[children.length - 1];
    Node removedNode = null;
    int tempIndex = 0;
    for(int i = 0; i < children.length; i++) {
      if(i != index) {
        temp[tempIndex] = children[i];
        tempIndex++;
      } else {
          removedNode = children[i];
      }
    }

    children = temp;
    return removedNode;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return TestParserTreeConstants.jjtNodeName[id];
  }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  /** Accept the visitor. **/
  @Override
  public Object jjtAccept(TestParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

  /** Accept the visitor. **/
  public Object childrenAccept(TestParserVisitor visitor, Object data) {
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);
      }
    }
    return data;
  }

  public int getId() {
    return id;
  }
}

/* JavaCC - OriginalChecksum=99f085252c714fb357dbc394eadfb753 (do not edit this line) */
