/* TestParser.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. TestParser.java */
package Compiler.Parser.GeneratedFiles;

import Compiler.Parser.CustomVisitors.*;
import Compiler.Parser.TreePrinter;
import Compiler.SymbolTable.Table.SymbolTable;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

public class TestParser/*@bgen(jjtree)*/implements TestParserTreeConstants, TestParserConstants {/*@bgen(jjtree)*/
  protected JJTTestParserState jjtree = new JJTTestParserState();public static void main(String[] args) {
        try {
            SymbolTable st = new SymbolTable();
            st.openScope();
            useVisitorMethods("src/Compiler/Parser/test", st, new TreeOptimizerVisitor(), new FunctionVisitor(), new ReachabilityVisitor(), new StaticSemanticsVisitor(st), new CodeGenerationVisitor());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String parseTextFile(String filePath) throws Exception {
        Node root = createParseTree(filePath);
        return TreePrinter.createDotOutput(root);
  }

    public static Node useVisitorMethods(String filePath, Object data, TestParserVisitor... visitors) throws Exception {
        Node root = createParseTree(filePath);
        for (int i = 0; i < visitors.length; i++) {
            root.jjtAccept(visitors[i], data);
        }
        return root;
    }

    public static Node createParseTree(String filePath) throws Exception {
        File file = new File(filePath);
        BufferedReader reader = new BufferedReader(new FileReader(file));
        TestParser parser = new TestParser(reader);
        return parser.start();
    }

  void skip_to_first_dcl() throws ParseException {Token tok;
      while (true) {
        tok = getToken(1);
        if (tok.kind != NEWLINE)
            break;
        tok = getNextToken();
      }
  }

  void skip_to_EOF() throws ParseException {Token tok;
      while (true) {
        tok = getToken(1);
        if (tok.kind == EOF)
            break;
        else if (tok.kind != NEWLINE)
            throw new ParseException("Encountered '" + tok.kind + "'. Was expecting: '<NEWLINE>' or '<EOF>'");
        tok = getNextToken();
      }
  }

  final public SimpleNode start() throws ParseException {/*@bgen(jjtree) START */
  ASTSTART jjtn000 = new ASTSTART(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      prog();
jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void prog() throws ParseException {/*@bgen(jjtree) #PROG(> 1) */
  ASTPROG jjtn000 = new ASTPROG(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      newlines_star();
      vertex_edge_attributes();
      main();
      newlines_star();
ASTFUNCS_DCL jjtn001 = new ASTFUNCS_DCL(JJTFUNCS_DCL);
                                                                      boolean jjtc001 = true;
                                                                      jjtree.openNodeScope(jjtn001);
                                                                      jjtn001.jjtSetFirstToken(getToken(1));
      try {
        funcs_dcl();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                                                        jjtree.clearNodeScope(jjtn001);
                                                                        jjtc001 = false;
                                                                      } else {
                                                                        jjtree.popNode();
                                                                      }
                                                                      if (jjte001 instanceof RuntimeException) {
                                                                        {if (true) throw (RuntimeException)jjte001;}
                                                                      }
                                                                      if (jjte001 instanceof ParseException) {
                                                                        {if (true) throw (ParseException)jjte001;}
                                                                      }
                                                                      {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                                                        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                                                                        jjtn001.jjtSetLastToken(getToken(0));
                                                                      }
      }
      jj_consume_token(0);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void newlines_plus() throws ParseException {
    jj_consume_token(NEWLINE);
    newlines_star();
  }

  final public void newlines_star() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEWLINE:{
      jj_consume_token(NEWLINE);
      newlines_star();
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      empty();
    }
  }

  final public void vertex_edge_attributes() throws ParseException {/*@bgen(jjtree) #VERTEX_EDGE_ATTR(> 1) */
  ASTVERTEX_EDGE_ATTR jjtn000 = new ASTVERTEX_EDGE_ATTR(JJTVERTEX_EDGE_ATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VERTEX:{
        vertex_attributes();
        break;
        }
      case EDGE:{
        edge_attributes();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        empty();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void vertex_attributes() throws ParseException {
    vertex_attr_dcl();
    newlines_star();
    vertex_attr_tail();
  }

  final public void vertex_attr_dcl() throws ParseException {/*@bgen(jjtree) VERTEX_ATTRIBUTES */
  ASTVERTEX_ATTRIBUTES jjtn000 = new ASTVERTEX_ATTRIBUTES(JJTVERTEX_ATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(VERTEX);
      jj_consume_token(DCL);
      newlines_plus();
      attribute_dcl();
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void vertex_attr_tail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EDGE:{
      edge_attr_dcl();
      newlines_star();
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      empty();
    }
  }

  final public void edge_attributes() throws ParseException {
    edge_attr_dcl();
    newlines_star();
    edge_attr_tail();
  }

  final public void edge_attr_dcl() throws ParseException {/*@bgen(jjtree) EDGE_ATTRIBUTES */
  ASTEDGE_ATTRIBUTES jjtn000 = new ASTEDGE_ATTRIBUTES(JJTEDGE_ATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(EDGE);
      jj_consume_token(DCL);
      newlines_plus();
      attribute_dcl();
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void edge_attr_tail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VERTEX:{
      vertex_attr_dcl();
      newlines_star();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      empty();
    }
  }

  final public void attribute_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VERTEX:
    case EDGE:
    case DIEDGE:
    case INT:
    case REAL:
    case BOOLEAN:
    case MAP:
    case COLOR:
    case LABEL:
    case GRAPH_TYPE:
    case COLLECTION_TYPE:{
ASTATTRIBUTES_DCL jjtn001 = new ASTATTRIBUTES_DCL(JJTATTRIBUTES_DCL);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
      try {
        type();
        identifier();
      } catch (Throwable jjte001) {
if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
      }
      newlines_plus();
      attribute_dcl();
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      empty();
    }
  }

  final public void simple_dcl() throws ParseException {/*@bgen(jjtree) SIMPLE_DCL */
  ASTSIMPLE_DCL jjtn000 = new ASTSIMPLE_DCL(JJTSIMPLE_DCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      type();
      identifier();
      initialization();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void simple_types() throws ParseException {/*@bgen(jjtree) SIMPLE_TYPES */
 ASTSIMPLE_TYPES jjtn000 = new ASTSIMPLE_TYPES(JJTSIMPLE_TYPES);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:{
        t = jj_consume_token(INT);
jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case REAL:{
        t = jj_consume_token(REAL);
jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                            jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case BOOLEAN:{
        t = jj_consume_token(BOOLEAN);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                         jjtc000 = false;
                                                                                                         jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case LABEL:{
        t = jj_consume_token(LABEL);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                  jjtc000 = false;
                                                                                                                                                  jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case COLOR:{
        t = jj_consume_token(COLOR);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                           jjtc000 = false;
                                                                                                                                                                                           jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case VERTEX:{
        t = jj_consume_token(VERTEX);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                     jjtc000 = false;
                                                                                                                                                                                                                                     jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case EDGE:{
        t = jj_consume_token(EDGE);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                             jjtc000 = false;
                                                                                                                                                                                                                                                                             jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      case DIEDGE:{
        t = jj_consume_token(DIEDGE);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                       jjtc000 = false;
                                                                                                                                                                                                                                                                                                                       jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void identifier() throws ParseException {/*@bgen(jjtree) IDENTIFIER */
 ASTIDENTIFIER jjtn000 = new ASTIDENTIFIER(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void initialization() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      jj_consume_token(ASSIGN);
ASTINITIALIZATION jjtn001 = new ASTINITIALIZATION(JJTINITIALIZATION);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
                 jjtn001.jjtSetFirstToken(getToken(1));
      try {
        expr();
      } catch (Throwable jjte001) {
if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   {if (true) throw (RuntimeException)jjte001;}
                 }
                 if (jjte001 instanceof ParseException) {
                   {if (true) throw (ParseException)jjte001;}
                 }
                 {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtn001.jjtSetLastToken(getToken(0));
                 }
      }
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      empty();
    }
  }

  final public void object_types() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GRAPH_TYPE:{
      graph_type();
      break;
      }
    case COLLECTION_TYPE:{
      collection_type();
      break;
      }
    case MAP:{
      map();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void map() throws ParseException {/*@bgen(jjtree) MAP */
  ASTMAP jjtn000 = new ASTMAP(JJTMAP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(MAP);
      jj_consume_token(LANGLE);
      type();
      jj_consume_token(COMMA);
      type();
      jj_consume_token(RANGLE);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void collection_type() throws ParseException {/*@bgen(jjtree) COLLECTION_TYPE */
 ASTCOLLECTION_TYPE jjtn000 = new ASTCOLLECTION_TYPE(JJTCOLLECTION_TYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(COLLECTION_TYPE);
      jj_consume_token(LANGLE);
      simple_types();
      jj_consume_token(RANGLE);
jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                             jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void expr() throws ParseException {/*@bgen(jjtree) #OR_EXPR(> 1) */
  ASTOR_EXPR jjtn000 = new ASTOR_EXPR(JJTOR_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      and_expr();
      A();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void A() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OR:{
      jj_consume_token(OR);
      and_expr();
      A();
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      empty();
    }
  }

  final public void and_expr() throws ParseException {/*@bgen(jjtree) #AND_EXPR(> 1) */
  ASTAND_EXPR jjtn000 = new ASTAND_EXPR(JJTAND_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      equal_expr();
      B();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void B() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AND:{
      jj_consume_token(AND);
      equal_expr();
      B();
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      empty();
    }
  }

  final public void equal_expr() throws ParseException {/*@bgen(jjtree) #EQUAL_EXPR(> 1) */
 ASTEQUAL_EXPR jjtn000 = new ASTEQUAL_EXPR(JJTEQUAL_EXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      rel_expr();
      t = equal_expr1();
jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                                   jjtc000 = false;
                                   jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public Token equal_expr1() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALITY_OP:{
      t = jj_consume_token(EQUALITY_OP);
      rel_expr();
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      empty();
{if ("" != null) return new Token();}
    }
    throw new Error("Missing return statement in function");
  }

  final public void rel_expr() throws ParseException {/*@bgen(jjtree) #REL_EXPR(> 1) */
 ASTREL_EXPR jjtn000 = new ASTREL_EXPR(JJTREL_EXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      arith_expr();
      t = rel_expr1();
jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                                   jjtc000 = false;
                                   jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public Token rel_expr1() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RELATIONAL_OP:
    case LANGLE:
    case RANGLE:{
      t = relational_op();
      arith_expr();
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      empty();
{if ("" != null) return new Token();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Token relational_op() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LANGLE:{
      t = jj_consume_token(LANGLE);
{if ("" != null) return t;}
      break;
      }
    case RANGLE:{
      t = jj_consume_token(RANGLE);
{if ("" != null) return t;}
      break;
      }
    case RELATIONAL_OP:{
      t = jj_consume_token(RELATIONAL_OP);
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void arith_expr() throws ParseException {/*@bgen(jjtree) #ADD_SUB(> 1) */
 ASTADD_SUB jjtn000 = new ASTADD_SUB(JJTADD_SUB);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      term();
      t = C();
jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                   jjtc000 = false;
                   jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
      jjtn000.jjtSetLastToken(getToken(0));
    }
    }
  }

  final public Token C() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ADD_SUB:{
      t = jj_consume_token(ADD_SUB);
      term();
      C();
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      empty();
{if ("" != null) return new Token();}
    }
    throw new Error("Missing return statement in function");
  }

  final public void term() throws ParseException {/*@bgen(jjtree) #MUL_DIV_MOD(> 1) */
 ASTMUL_DIV_MOD jjtn000 = new ASTMUL_DIV_MOD(JJTMUL_DIV_MOD);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      neg_expr();
      t = D();
jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                         jjtc000 = false;
                         jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public Token D() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MUL_DIV_MOD:{
      t = jj_consume_token(MUL_DIV_MOD);
      atomic_expr();
      D();
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      empty();
{if ("" != null) return new Token();}
    }
    throw new Error("Missing return statement in function");
  }

  final public void neg_expr() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEG:{
      jj_consume_token(NEG);
ASTNEG_EXPR jjtn001 = new ASTNEG_EXPR(JJTNEG_EXPR);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtn001.jjtSetFirstToken(getToken(1));
      try {
        atomic_expr();
      } catch (Throwable jjte001) {
if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               {if (true) throw (RuntimeException)jjte001;}
             }
             if (jjte001 instanceof ParseException) {
               {if (true) throw (ParseException)jjte001;}
             }
             {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
               jjtn001.jjtSetLastToken(getToken(0));
             }
      }
      break;
      }
    case LPAREN:
    case BOOL_VAL:
    case CONSTANTS:
    case COLOR_VAL:
    case INUM_VAL:
    case FNUM_VAL:
    case IDENTIFIER:
    case LABEL_VAL:{
      atomic_expr();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void atomic_expr() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      expr();
      jj_consume_token(RPAREN);
      break;
      }
    case BOOL_VAL:
    case CONSTANTS:
    case COLOR_VAL:
    case INUM_VAL:
    case FNUM_VAL:
    case IDENTIFIER:
    case LABEL_VAL:{
      value();
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void value() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      variable_or_function();
      break;
      }
    case INUM_VAL:{
      inum_val();
      break;
      }
    case FNUM_VAL:{
      fnum_val();
      break;
      }
    case BOOL_VAL:{
      bool_val();
      break;
      }
    case CONSTANTS:{
      constant_val();
      break;
      }
    case COLOR_VAL:{
      color_val();
      break;
      }
    case LABEL_VAL:{
      label_val();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void inum_val() throws ParseException {/*@bgen(jjtree) INUM_VAL */
 ASTINUM_VAL jjtn000 = new ASTINUM_VAL(JJTINUM_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(INUM_VAL);
jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void fnum_val() throws ParseException {/*@bgen(jjtree) FNUM_VAL */
 ASTFNUM_VAL jjtn000 = new ASTFNUM_VAL(JJTFNUM_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(FNUM_VAL);
jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void bool_val() throws ParseException {/*@bgen(jjtree) BOOL_VAL */
 ASTBOOL_VAL jjtn000 = new ASTBOOL_VAL(JJTBOOL_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(BOOL_VAL);
jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void constant_val() throws ParseException {/*@bgen(jjtree) CONSTANT_VAL */
 ASTCONSTANT_VAL jjtn000 = new ASTCONSTANT_VAL(JJTCONSTANT_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(CONSTANTS);
jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                      jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void color_val() throws ParseException {/*@bgen(jjtree) COLOR_VAL */
 ASTCOLOR_VAL jjtn000 = new ASTCOLOR_VAL(JJTCOLOR_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(COLOR_VAL);
jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                      jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void label_val() throws ParseException {/*@bgen(jjtree) LABEL_VAL */
 ASTLABEL_VAL jjtn000 = new ASTLABEL_VAL(JJTLABEL_VAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(LABEL_VAL);
jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                      jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void variable_or_function() throws ParseException {int varFieldFunc = 0;
ASTFUNCTION_CALL jjtn002 = new ASTFUNCTION_CALL(JJTFUNCTION_CALL);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtn002.jjtSetFirstToken(getToken(1));
    try {
ASTVARIABLE jjtn001 = new ASTVARIABLE(JJTVARIABLE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtn001.jjtSetFirstToken(getToken(1));
      try {
        identifier();
        varFieldFunc = variable_or_function_tail();
      } catch (Throwable jjte001) {
if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte001;}
       }
       if (jjte001 instanceof ParseException) {
         {if (true) throw (ParseException)jjte001;}
       }
       {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  varFieldFunc == 0 || varFieldFunc == 1);
         jjtn001.jjtSetLastToken(getToken(0));
       }
      }
    } catch (Throwable jjte002) {
if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
    } finally {
if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  varFieldFunc == 2);
        jjtn002.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public int variable_or_function_tail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
      field_access();
{if ("" != null) return 1;}
      break;
      }
    case LPAREN:{
      function_call();
{if ("" != null) return 2;}
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      empty();
{if ("" != null) return 0;}
    }
    throw new Error("Missing return statement in function");
  }

  final public void field_access() throws ParseException {int varFieldFunc = 0;
ASTFUNCTION_CALL jjtn002 = new ASTFUNCTION_CALL(JJTFUNCTION_CALL);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtn002.jjtSetFirstToken(getToken(1));
    try {
ASTFIELD_ACCESS jjtn001 = new ASTFIELD_ACCESS(JJTFIELD_ACCESS);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtn001.jjtSetFirstToken(getToken(1));
      try {
        jj_consume_token(DOT);
        identifier();
        varFieldFunc = variable_or_function_tail();
      } catch (Throwable jjte001) {
if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte001;}
       }
       if (jjte001 instanceof ParseException) {
         {if (true) throw (ParseException)jjte001;}
       }
       {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  varFieldFunc == 0 || varFieldFunc == 1);
         jjtn001.jjtSetLastToken(getToken(0));
       }
      }
    } catch (Throwable jjte002) {
if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
    } finally {
if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  varFieldFunc == 2);
        jjtn002.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void function_call() throws ParseException {
    jj_consume_token(LPAREN);
    actual_parameters();
    jj_consume_token(RPAREN);
    function_tail();
  }

  final public void function_tail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
      field_access();
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      empty();
    }
  }

  final public void actual_parameters() throws ParseException {/*@bgen(jjtree) ACTUAL_PARAMETERS */
  ASTACTUAL_PARAMETERS jjtn000 = new ASTACTUAL_PARAMETERS(JJTACTUAL_PARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NEG:
      case LPAREN:
      case BOOL_VAL:
      case CONSTANTS:
      case COLOR_VAL:
      case INUM_VAL:
      case FNUM_VAL:
      case IDENTIFIER:
      case LABEL_VAL:{
        actual_parameter_list();
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        empty();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void actual_parameter_list() throws ParseException {
    expr();
    actual_parameter_list1();
  }

  final public void actual_parameter_list1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      jj_consume_token(COMMA);
      actual_parameter_list();
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      empty();
    }
  }

  final public void main() throws ParseException {/*@bgen(jjtree) MAIN */
  ASTMAIN jjtn000 = new ASTMAIN(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FUNCTION);
      jj_consume_token(MAIN);
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                                             boolean jjtc001 = true;
                                                             jjtree.openNodeScope(jjtn001);
                                                             jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                                               jjtree.clearNodeScope(jjtn001);
                                                               jjtc001 = false;
                                                             } else {
                                                               jjtree.popNode();
                                                             }
                                                             if (jjte001 instanceof RuntimeException) {
                                                               {if (true) throw (RuntimeException)jjte001;}
                                                             }
                                                             if (jjte001 instanceof ParseException) {
                                                               {if (true) throw (ParseException)jjte001;}
                                                             }
                                                             {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                                               jjtree.closeNodeScope(jjtn001, true);
                                                               jjtn001.jjtSetLastToken(getToken(0));
                                                             }
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void block() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CREATE:
    case NEWLINE:
    case WHILE:
    case FOR:
    case FOREACH:
    case IF:
    case VERTEX:
    case EDGE:
    case DIEDGE:
    case INT:
    case REAL:
    case BOOLEAN:
    case RETURN:
    case MAP:
    case COLOR:
    case LABEL:
    case GRAPH_TYPE:
    case COLLECTION_TYPE:
    case IDENTIFIER:{
      block_content();
      jj_consume_token(NEWLINE);
      block();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      empty();
    }
  }

  final public void block_content() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CREATE:
    case VERTEX:
    case EDGE:
    case DIEDGE:
    case INT:
    case REAL:
    case BOOLEAN:
    case MAP:
    case COLOR:
    case LABEL:
    case GRAPH_TYPE:
    case COLLECTION_TYPE:{
      dcl();
      break;
      }
    case WHILE:
    case FOR:
    case FOREACH:
    case IF:
    case RETURN:
    case IDENTIFIER:{
      stmt();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      empty();
    }
  }

  final public void dcl() throws ParseException {/*@bgen(jjtree) DCL */
  ASTDCL jjtn000 = new ASTDCL(JJTDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VERTEX:
      case EDGE:
      case DIEDGE:
      case INT:
      case REAL:
      case BOOLEAN:
      case MAP:
      case COLOR:
      case LABEL:
      case GRAPH_TYPE:
      case COLLECTION_TYPE:{
        simple_dcl();
        break;
        }
      case CREATE:{
        create();
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void create() throws ParseException {
    jj_consume_token(CREATE);
    adt();
    jj_consume_token(END);
  }

  final public void adt() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GRAPH_TYPE:{
      graph_adt();
      break;
      }
    case COLLECTION_TYPE:{
      collection_adt();
      break;
      }
    case MAP:{
      map_adt();
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void graph_adt() throws ParseException {/*@bgen(jjtree) GRAPH_DCL */
  ASTGRAPH_DCL jjtn000 = new ASTGRAPH_DCL(JJTGRAPH_DCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      graph_type();
      identifier();
      graph_dcl();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void graph_type() throws ParseException {/*@bgen(jjtree) GRAPH_TYPE */
 ASTGRAPH_TYPE jjtn000 = new ASTGRAPH_TYPE(JJTGRAPH_TYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      t = jj_consume_token(GRAPH_TYPE);
jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void graph_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEWLINE:{
ASTGRAPH_DCL_ELEMENTS jjtn001 = new ASTGRAPH_DCL_ELEMENTS(JJTGRAPH_DCL_ELEMENTS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
      try {
        newlines_plus();
        graph_vertex_dcl();
        newlines_plus();
        graph_elements();
      } catch (Throwable jjte001) {
if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
      }
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      empty();
    }
  }

  final public void graph_elements() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      graph_vertex_dcl();
      newlines_plus();
      graph_elements();
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      empty();
    }
  }

  final public void graph_vertex_dcl() throws ParseException {/*@bgen(jjtree) GRAPH_VERTEX_DCL */
  ASTGRAPH_VERTEX_DCL jjtn000 = new ASTGRAPH_VERTEX_DCL(JJTGRAPH_VERTEX_DCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      identifier();
      edge_dcl();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void edge_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CONNECTION:{
      jj_consume_token(CONNECTION);
      graph_vertex_dcl1();
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      empty();
    }
  }

  final public void graph_vertex_dcl1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LCURLY:{
      jj_consume_token(LCURLY);
ASTVERTEX_LIST jjtn001 = new ASTVERTEX_LIST(JJTVERTEX_LIST);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
                 jjtn001.jjtSetFirstToken(getToken(1));
      try {
        vertex_list();
      } catch (Throwable jjte001) {
if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   {if (true) throw (RuntimeException)jjte001;}
                 }
                 if (jjte001 instanceof ParseException) {
                   {if (true) throw (ParseException)jjte001;}
                 }
                 {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtn001.jjtSetLastToken(getToken(0));
                 }
      }
      jj_consume_token(RCURLY);
      break;
      }
    case IDENTIFIER:{
      identifier();
      weight();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void vertex_list() throws ParseException {
ASTVERTEX jjtn001 = new ASTVERTEX(JJTVERTEX);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
    try {
      identifier();
      weight();
    } catch (Throwable jjte001) {
if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
    } finally {
if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
    }
    vertex_list_continuous();
  }

  final public void vertex_list_continuous() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      jj_consume_token(COMMA);
      vertex_list();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      empty();
    }
  }

  final public void weight() throws ParseException {/*@bgen(jjtree) WEIGHT */
  ASTWEIGHT jjtn000 = new ASTWEIGHT(JJTWEIGHT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LHARD:{
        jj_consume_token(LHARD);
        arith_expr();
        jj_consume_token(RHARD);
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        empty();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void stmt() throws ParseException {boolean isAssign = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
ASTFUNCTION_CALL_STMT jjtn002 = new ASTFUNCTION_CALL_STMT(JJTFUNCTION_CALL_STMT);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtn002.jjtSetFirstToken(getToken(1));
      try {
ASTASSIGN jjtn001 = new ASTASSIGN(JJTASSIGN);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtn001.jjtSetFirstToken(getToken(1));
        try {
          variable_or_function();
          isAssign = assign_or_func();
        } catch (Throwable jjte001) {
if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte001;}
       }
       if (jjte001 instanceof ParseException) {
         {if (true) throw (ParseException)jjte001;}
       }
       {if (true) throw (Error)jjte001;}
        } finally {
if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  isAssign);
         jjtn001.jjtSetLastToken(getToken(0));
       }
        }
      } catch (Throwable jjte002) {
if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte002;}
      }
      if (jjte002 instanceof ParseException) {
        {if (true) throw (ParseException)jjte002;}
      }
      {if (true) throw (Error)jjte002;}
      } finally {
if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  ! isAssign);
        jjtn002.jjtSetLastToken(getToken(0));
      }
      }
      break;
      }
    case WHILE:
    case FOR:
    case FOREACH:{
      loop();
      break;
      }
    case IF:{
      if_statement();
      break;
      }
    case RETURN:{
      return_statement();
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public boolean assign_or_func() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      assignment();
{if ("" != null) return true;}
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      empty();
{if ("" != null) return false;}
    }
    throw new Error("Missing return statement in function");
  }

  final public void assignment() throws ParseException {
    jj_consume_token(ASSIGN);
    expr();
  }

  final public void loop() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHILE:{
      while_statement();
      break;
      }
    case FOR:{
      for_statement();
      break;
      }
    case FOREACH:{
      foreach_statement();
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void while_statement() throws ParseException {/*@bgen(jjtree) WHILE_STATEMENT */
  ASTWHILE_STATEMENT jjtn000 = new ASTWHILE_STATEMENT(JJTWHILE_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(WHILE);
      expr();
      jj_consume_token(DO);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
                                          jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                            jjtree.clearNodeScope(jjtn001);
                                            jjtc001 = false;
                                          } else {
                                            jjtree.popNode();
                                          }
                                          if (jjte001 instanceof RuntimeException) {
                                            {if (true) throw (RuntimeException)jjte001;}
                                          }
                                          if (jjte001 instanceof ParseException) {
                                            {if (true) throw (ParseException)jjte001;}
                                          }
                                          {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001, true);
                                            jjtn001.jjtSetLastToken(getToken(0));
                                          }
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void for_statement() throws ParseException {/*@bgen(jjtree) FOR_STATEMENT */
  ASTFOR_STATEMENT jjtn000 = new ASTFOR_STATEMENT(JJTFOR_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FOR);
      identifier();
      jj_consume_token(ASSIGN);
      integer_value();
      jj_consume_token(TO);
      integer_value();
      jj_consume_token(DO);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                                                                                boolean jjtc001 = true;
                                                                                                jjtree.openNodeScope(jjtn001);
                                                                                                jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                                                                                  jjtree.clearNodeScope(jjtn001);
                                                                                                  jjtc001 = false;
                                                                                                } else {
                                                                                                  jjtree.popNode();
                                                                                                }
                                                                                                if (jjte001 instanceof RuntimeException) {
                                                                                                  {if (true) throw (RuntimeException)jjte001;}
                                                                                                }
                                                                                                if (jjte001 instanceof ParseException) {
                                                                                                  {if (true) throw (ParseException)jjte001;}
                                                                                                }
                                                                                                {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                                                                                  jjtree.closeNodeScope(jjtn001, true);
                                                                                                  jjtn001.jjtSetLastToken(getToken(0));
                                                                                                }
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void integer_value() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      variable_or_function();
      break;
      }
    case INUM_VAL:{
      inum_val();
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void foreach_statement() throws ParseException {/*@bgen(jjtree) FOREACH_STATEMENT */
  ASTFOREACH_STATEMENT jjtn000 = new ASTFOREACH_STATEMENT(JJTFOREACH_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(FOREACH);
      identifier();
      jj_consume_token(IN);
      variable_or_function();
      jj_consume_token(DO);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                                                                boolean jjtc001 = true;
                                                                                jjtree.openNodeScope(jjtn001);
                                                                                jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                                                                  jjtree.clearNodeScope(jjtn001);
                                                                                  jjtc001 = false;
                                                                                } else {
                                                                                  jjtree.popNode();
                                                                                }
                                                                                if (jjte001 instanceof RuntimeException) {
                                                                                  {if (true) throw (RuntimeException)jjte001;}
                                                                                }
                                                                                if (jjte001 instanceof ParseException) {
                                                                                  {if (true) throw (ParseException)jjte001;}
                                                                                }
                                                                                {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                                                                  jjtree.closeNodeScope(jjtn001, true);
                                                                                  jjtn001.jjtSetLastToken(getToken(0));
                                                                                }
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void if_statement() throws ParseException {/*@bgen(jjtree) IF_STATEMENT */
  ASTIF_STATEMENT jjtn000 = new ASTIF_STATEMENT(JJTIF_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(IF);
      expr();
      jj_consume_token(THEN);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
                                       jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                         jjtree.clearNodeScope(jjtn001);
                                         jjtc001 = false;
                                       } else {
                                         jjtree.popNode();
                                       }
                                       if (jjte001 instanceof RuntimeException) {
                                         {if (true) throw (RuntimeException)jjte001;}
                                       }
                                       if (jjte001 instanceof ParseException) {
                                         {if (true) throw (ParseException)jjte001;}
                                       }
                                       {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001, true);
                                         jjtn001.jjtSetLastToken(getToken(0));
                                       }
      }
      else_statement();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void else_statement() throws ParseException {/*@bgen(jjtree) ELSE_STATEMENT */
  ASTELSE_STATEMENT jjtn000 = new ASTELSE_STATEMENT(JJTELSE_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
               jjtn001.jjtSetFirstToken(getToken(1));
        try {
          block();
        } catch (Throwable jjte001) {
if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 {if (true) throw (RuntimeException)jjte001;}
               }
               if (jjte001 instanceof ParseException) {
                 {if (true) throw (ParseException)jjte001;}
               }
               {if (true) throw (Error)jjte001;}
        } finally {
if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001, true);
                 jjtn001.jjtSetLastToken(getToken(0));
               }
        }
        jj_consume_token(END);
        break;
        }
      case END:{
        jj_consume_token(END);
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void return_statement() throws ParseException {/*@bgen(jjtree) RETURN_STMT */
  ASTRETURN_STMT jjtn000 = new ASTRETURN_STMT(JJTRETURN_STMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(RETURN);
      return_expr();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void return_expr() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEG:
    case LPAREN:
    case BOOL_VAL:
    case CONSTANTS:
    case COLOR_VAL:
    case INUM_VAL:
    case FNUM_VAL:
    case IDENTIFIER:
    case LABEL_VAL:{
      expr();
      break;
      }
    default:
      jj_la1[37] = jj_gen;
      empty();
    }
  }

  final public void collection_adt() throws ParseException {/*@bgen(jjtree) COLLECTION_ADT */
  ASTCOLLECTION_ADT jjtn000 = new ASTCOLLECTION_ADT(JJTCOLLECTION_ADT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      collection_type();
      identifier();
      collection_dcl();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void collection_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEWLINE:{
      newlines_plus();
ASTELEMENT_LIST jjtn001 = new ASTELEMENT_LIST(JJTELEMENT_LIST);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                     jjtn001.jjtSetFirstToken(getToken(1));
      try {
        element_list();
      } catch (Throwable jjte001) {
if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       {if (true) throw (RuntimeException)jjte001;}
                     }
                     if (jjte001 instanceof ParseException) {
                       {if (true) throw (ParseException)jjte001;}
                     }
                     {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtn001.jjtSetLastToken(getToken(0));
                     }
      }
      break;
      }
    default:
      jj_la1[38] = jj_gen;
      empty();
    }
  }

  final public void element_list() throws ParseException {
    expr();
    newlines_plus();
    element_list_continuous();
  }

  final public void element_list_continuous() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEG:
    case LPAREN:
    case BOOL_VAL:
    case CONSTANTS:
    case COLOR_VAL:
    case INUM_VAL:
    case FNUM_VAL:
    case IDENTIFIER:
    case LABEL_VAL:{
      element_list();
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      empty();
    }
  }

  final public void map_adt() throws ParseException {/*@bgen(jjtree) MAP_ADT */
  ASTMAP_ADT jjtn000 = new ASTMAP_ADT(JJTMAP_ADT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(MAP);
      jj_consume_token(LANGLE);
      simple_types();
      jj_consume_token(COMMA);
      simple_types();
      jj_consume_token(RANGLE);
      identifier();
      map_dcl();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void map_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEWLINE:{
      newlines_plus();
ASTMAP_ELEMENT_LIST jjtn001 = new ASTMAP_ELEMENT_LIST(JJTMAP_ELEMENT_LIST);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtn001.jjtSetFirstToken(getToken(1));
      try {
        map_element_list();
      } catch (Throwable jjte001) {
if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        {if (true) throw (RuntimeException)jjte001;}
                      }
                      if (jjte001 instanceof ParseException) {
                        {if (true) throw (ParseException)jjte001;}
                      }
                      {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001, true);
                        jjtn001.jjtSetLastToken(getToken(0));
                      }
      }
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      empty();
    }
  }

  final public void map_element_list() throws ParseException {
ASTKEY_VALUE_PAIR jjtn001 = new ASTKEY_VALUE_PAIR(JJTKEY_VALUE_PAIR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
    try {
      value();
      jj_consume_token(CONNECTION);
      value();
    } catch (Throwable jjte001) {
if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
    } finally {
if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
    }
    newlines_plus();
    map_element_list_continuous();
  }

  final public void map_element_list_continuous() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOL_VAL:
    case CONSTANTS:
    case COLOR_VAL:
    case INUM_VAL:
    case FNUM_VAL:
    case IDENTIFIER:
    case LABEL_VAL:{
      map_element_list();
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      empty();
    }
  }

  final public void funcs_dcl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FUNCTION:
    case VERTEX:
    case EDGE:
    case DIEDGE:
    case INT:
    case REAL:
    case BOOLEAN:
    case MAP:
    case COLOR:
    case LABEL:
    case GRAPH_TYPE:
    case COLLECTION_TYPE:{
      func_dcl();
      newlines_star();
      funcs_dcl();
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      empty();
    }
  }

  final public void func_dcl() throws ParseException {/*@bgen(jjtree) FUNC_DCL */
  ASTFUNC_DCL jjtn000 = new ASTFUNC_DCL(JJTFUNC_DCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      ret();
      jj_consume_token(FUNCTION);
      identifier();
      jj_consume_token(LPAREN);
      formal_parameters();
      jj_consume_token(RPAREN);
      jj_consume_token(NEWLINE);
ASTBLOCK jjtn001 = new ASTBLOCK(JJTBLOCK);
                                                                                          boolean jjtc001 = true;
                                                                                          jjtree.openNodeScope(jjtn001);
                                                                                          jjtn001.jjtSetFirstToken(getToken(1));
      try {
        block();
      } catch (Throwable jjte001) {
if (jjtc001) {
                                                                                            jjtree.clearNodeScope(jjtn001);
                                                                                            jjtc001 = false;
                                                                                          } else {
                                                                                            jjtree.popNode();
                                                                                          }
                                                                                          if (jjte001 instanceof RuntimeException) {
                                                                                            {if (true) throw (RuntimeException)jjte001;}
                                                                                          }
                                                                                          if (jjte001 instanceof ParseException) {
                                                                                            {if (true) throw (ParseException)jjte001;}
                                                                                          }
                                                                                          {if (true) throw (Error)jjte001;}
      } finally {
if (jjtc001) {
                                                                                            jjtree.closeNodeScope(jjtn001, true);
                                                                                            jjtn001.jjtSetLastToken(getToken(0));
                                                                                          }
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void ret() throws ParseException {/*@bgen(jjtree) RETURN_TYPE */
  ASTRETURN_TYPE jjtn000 = new ASTRETURN_TYPE(JJTRETURN_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VERTEX:
      case EDGE:
      case DIEDGE:
      case INT:
      case REAL:
      case BOOLEAN:
      case MAP:
      case COLOR:
      case LABEL:
      case GRAPH_TYPE:
      case COLLECTION_TYPE:{
        type();
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        empty();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void formal_parameters() throws ParseException {/*@bgen(jjtree) FORMAL_PARAMETERS */
  ASTFORMAL_PARAMETERS jjtn000 = new ASTFORMAL_PARAMETERS(JJTFORMAL_PARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VERTEX:
      case EDGE:
      case DIEDGE:
      case INT:
      case REAL:
      case BOOLEAN:
      case MAP:
      case COLOR:
      case LABEL:
      case GRAPH_TYPE:
      case COLLECTION_TYPE:{
        formal_parameter_list();
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        empty();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void formal_parameter_list() throws ParseException {
    formal_parameter();
    formal_parameter_list1();
  }

  final public void formal_parameter_list1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      jj_consume_token(COMMA);
      formal_parameter_list();
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      empty();
    }
  }

  final public void formal_parameter() throws ParseException {/*@bgen(jjtree) FORMAL_PARAMETER */
  ASTFORMAL_PARAMETER jjtn000 = new ASTFORMAL_PARAMETER(JJTFORMAL_PARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      type();
      identifier();
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
  }

  final public void type() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MAP:
    case GRAPH_TYPE:
    case COLLECTION_TYPE:{
      object_types();
      break;
      }
    case VERTEX:
    case EDGE:
    case DIEDGE:
    case INT:
    case REAL:
    case BOOLEAN:
    case COLOR:
    case LABEL:{
      simple_types();
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void empty() throws ParseException {

  }

  /** Generated Token Manager. */
  public TestParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[47];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x40000,0x20000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x2000,0x2000,0x80000,0x1000,0x2e00900,0x2e00100,0x100,0x0,0x800,0x0,0x0,0x10000000,0x1000,0x40000000,0x2e00000,0x10000,0xe00000,0x0,0x8000200,0x80000,0x800,0x80000,0x800,0x0,0x100000,0x0,0x0,0x1000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x18,0x10,0x8,0x8003c1f8,0x181f8,0x0,0x80024000,0x0,0x0,0x2000000,0x68000000,0x68000000,0x200000,0x800000,0x80201,0x80201,0x80200,0x1,0x0,0x80201,0x0,0x8003d1f8,0x8003d1f8,0x8003c1f8,0x80024000,0x0,0x0,0x4,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x80201,0x0,0x80201,0x0,0x80200,0x8003c1f8,0x8003c1f8,0x8003c1f8,0x0,0x8003c1f8,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x156,0x156,0x156,0x0,0x0,0x156,0x0,0x40,0x40,0x0,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x40,0x0,0x0,0x44,0x0,0x156,0x0,0x156,0x0,0x156,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public TestParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TestParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TestParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public TestParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TestParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public TestParser(TestParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(TestParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 47; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[73];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 47; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 73; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
